## level 1

runing the program demand a key input:

```bash
➜  binary ./level1 
Please enter key: test
Nope.
```

gdb used to dissas the program or other tools lets break this down to understand what we need;

```bash
   0x000011ca <+10>:	call   0x11cf <main+15>              ; Call the next instruction to get EIP on the stack (for position-independent code)
   0x000011cf <+15>:	pop    %ebx
   0x000011d0 <+16>:	add    $0x2e31,%ebx
   0x000011d6 <+22>:	mov    %ebx,-0x80(%ebp)

   0x000011d9 <+25>:	movl   $0x0,-0x8(%ebp)

   0x000011e0 <+32>:	mov    -0x1ff8(%ebx),%eax
   0x000011e6 <+38>:	mov    %eax,-0x7a(%ebp)
   0x000011e9 <+41>:	mov    -0x1ff4(%ebx),%eax
   0x000011ef <+47>:	mov    %eax,-0x76(%ebp)
   0x000011f2 <+50>:	mov    -0x1ff0(%ebx),%eax
   0x000011f8 <+56>:	mov    %eax,-0x72(%ebp)
   0x000011fb <+59>:	mov    -0x1fec(%ebx),%ax
   0x00001202 <+66>:	mov    %ax,-0x6e(%ebp)

   0x00001206 <+70>:	lea    -0x1fea(%ebx),%eax
   0x0000120c <+76>:	mov    %eax,(%esp)
   0x0000120f <+79>:	call   0x1060 <printf@plt>            ; Call printf
   
   0x00001214 <+84>:	mov    -0x80(%ebp),%ebx
   0x00001217 <+87>:	lea    -0x6c(%ebp),%eax
   0x0000121a <+90>:	lea    -0x1fd7(%ebx),%ecx
   0x00001220 <+96>:	mov    %ecx,(%esp)
   0x00001223 <+99>:	mov    %eax,0x4(%esp)
   0x00001227 <+103>:	call   0x1070 <__isoc99_scanf@plt>    ; scanf function call to get the user input 

   ; Call strcmp with user input and expected string
   0x0000122c <+108>:	mov    -0x80(%ebp),%ebx               ; Reload EBX (base address)
   0x0000122f <+111>:	lea    -0x6c(%ebp),%ecx               ; ECX → address of user input
   0x00001232 <+114>:	lea    -0x7a(%ebp),%edx               ; EDX → address of expected string
   0x00001235 <+117>:	mov    %esp,%eax                      ; EAX = ESP, prepare for calling strcmp
   0x00001237 <+119>:	mov    %edx,0x4(%eax)                 ; *(ESP+4) = expected string
   0x0000123a <+122>:	mov    %ecx,(%eax)                    ; *(ESP) = user input
   0x0000123c <+124>:	call   0x1040 <strcmp@plt>            ; strcmp call which compares the input value (ECX) with the expected value (EDX)

   0x00001241 <+129>:	cmp    $0x0,%eax                      ; Compare result of strcmp with 0 (equal)
```

so we need to break at strcmp and exploit the esp and esp +4 to see the stcmp used vars

lets do that

```bash
➜  binary gdb -q ./level1 
Reading symbols from ./level1...
(No debugging symbols found in ./level1)

(gdb) b strcmp                             ; Set a breakpoint at strcmp (where the user input is compared to the correct key)

Breakpoint 1 at 0x1040

(gdb) run                                  ; Start the program
Starting program: /home/mchliyah/Downloads/binary/level1 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Please enter key: test                     ; Enter any input to see how it is processed

Breakpoint 1, 0xf7f003c0 in ?? ()          ; Execution breaks inside strcmp

   from /lib/i386-linux-gnu/libc.so.6

(gdb) x/s $ecx                             ; Inspect first argument to strcmp: the user input string (ECX = user input)
0xffffccfc:	"test"                        ; as expected "test"

(gdb) x/s $edx                             ; Inspect second argument to strcmp: the expected string from the program (EDX = correct key)
0xffffccee:	"__stack_check"              ; This is the full expected key hardcoded in the binary
```

lets test it now in the binary:

```bash
➜  binary ./level1 
Please enter key: __stack_check
Good job.
```