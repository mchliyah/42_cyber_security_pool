## level2
##### Running the program demands a key input:

```bash
âžœ  binary ./level2 
Please enter key: test
Nope.
```
##### Analysis of the Binary

based on gdb output:
```bash
Dump of assembler code for function main:
   ; Function prologue
   0x000012d0 <+0>:	push   %ebp
   0x000012d1 <+1>:	mov    %esp,%ebp
   0x000012d3 <+3>:	push   %ebx
   0x000012d4 <+4>:	sub    $0x54,%esp      ; Allocate stack space
   0x000012d7 <+7>:	call   0x12dc <main+12>
   0x000012dc <+12>:	pop    %ebx           ; Get current address
   0x000012dd <+13>:	add    $0x5d24,%ebx   ; Calculate GOT address
   0x000012e3 <+19>:	mov    %ebx,-0x40(%ebp) ; Store GOT pointer
   0x000012ed <+29>:	lea    -0x42e5(%ebx),%eax ; Load prompt string
   0x000012f3 <+35>:	mov    %eax,(%esp)
   0x000012f6 <+38>:	call   0x1060 <printf@plt> ; "Please enter key: "
   0x000012fb <+43>:	mov    -0x40(%ebp),%ebx
   0x000012fe <+46>:	lea    -0x35(%ebp),%eax ; input buffer
   0x00001301 <+49>:	lea    -0x42d2(%ebx),%ecx ; scanf format string
   0x00001307 <+55>:	mov    %ecx,(%esp)
   0x0000130a <+58>:	mov    %eax,0x4(%esp)
   0x0000130e <+62>:	call   0x10c0 <__isoc99_scanf@plt>
   0x00001313 <+67>:	mov    %eax,-0xc(%ebp) ; Store return value
   0x00001316 <+70>:	mov    $0x1,%eax
   0x0000131b <+75>:	cmp    -0xc(%ebp),%eax ; Check if 1 item read
   0x0000131e <+78>:	je     0x132c <main+92>
   0x00001324 <+84>:	mov    -0x40(%ebp),%ebx
   0x00001327 <+87>:	call   0x1220 <no>    ; Fail if scanf failed
   0x0000132c <+92>:	movsbl -0x34(%ebp),%ecx ; input[1]
   0x00001330 <+96>:	mov    $0x30,%eax      ; ASCII '0'
   0x00001335 <+101>:	cmp    %ecx,%eax
   0x00001337 <+103>:	je     0x1345 <main+117>
   0x0000133d <+109>:	call   0x1220 <no>    ; Fail if not '0'
   0x00001345 <+117>:	movsbl -0x35(%ebp),%ecx ; input[0]
   0x00001349 <+121>:	mov    $0x30,%eax
   0x0000134e <+126>:	cmp    %ecx,%eax
   0x00001350 <+128>:	je     0x135e <main+142>
   0x00001356 <+134>:	call   0x1220 <no>    ; Fail if not '0'
   0x0000135e <+142>:	mov    -0x40(%ebp),%ebx
   0x0000137a <+170>:	lea    -0x1d(%ebp),%eax ; target buffer
   0x0000137d <+173>:	xor    %ecx,%ecx
   0x00001382 <+178>:	movl   $0x0,0x4(%esp) ; memset args
   0x0000138a <+186>:	movl   $0x9,0x8(%esp) ; sizeof(target)
   0x00001392 <+194>:	call   0x10b0 <memset@plt> ; Zero target buffer
   0x00001397 <+199>:	movb   $0x64,-0x1d(%ebp) ; target[0] = 'd'
   0x0000139f <+207>:	movl   $0x2,-0x14(%ebp) ; J = 2 (input index)
   0x000013a6 <+214>:	movl   $0x1,-0x10(%ebp) ; i = 1 (target index)
   0x000013ad <+221>:	mov    -0x40(%ebp),%ebx # starting main loop 
   0x000013b0 <+224>:	lea    -0x1d(%ebp),%ecx ; target
   0x000013b3 <+227>:	call   0x10a0 <strlen@plt> ; Get current length
   0x000013c0 <+240>:	cmp    $0x8,%ecx       ; Check if target complete
   0x000013c3 <+243>:	mov    %al,-0x41(%ebp)
   0x000013c6 <+246>:	jae    0x13ee <main+286> ; Exit if done
   0x000013fe <+302>:	mov    -0x14(%ebp),%eax ; J
   0x00001404 <+308>:	mov    -0x35(%ebp,%eax,1),%al ; input[J]
   0x00001408 <+312>:	mov    %al,-0x39(%ebp) ; chunk[0]
   0x0000140e <+318>:	mov    -0x34(%ebp,%eax,1),%al ; input[J+1]
   0x00001412 <+322>:	mov    %al,-0x38(%ebp) ; chunk[1]
   0x00001418 <+328>:	mov    -0x33(%ebp,%eax,1),%al ; input[J+2]
   0x0000141c <+332>:	mov    %al,-0x37(%ebp) ; chunk[2]  #filling 3 caracter input at time we need to remember this when converting some ascii are just two caracters
   0x0000141f <+335>:	lea    -0x39(%ebp),%eax ; chunk
   0x00001422 <+338>:	call   0x10d0 <atoi@plt> ; Convert to integer
   0x0000142a <+346>:	mov    %al,%cl         ; Get ASCII char
   0x0000142f <+351>:	mov    %cl,-0x1d(%ebp,%eax,1) ; target[i] = char
   0x00001436 <+358>:	add    $0x3,-0x14(%ebp) ; J += 3
   0x0000143c <+364>:	add    $0x1,-0x10(%ebp) ; i += 1
   0x00001445 <+373>:	jmp    0x13ad <main+221> ; Loop
   0x0000144a <+378>:	movb   $0x0,-0x1d(%ebp,%eax,1) ; Null-terminate
   0x00001455 <+389>:	lea    -0x1d(%ebp),%ecx ; target
   0x00001458 <+392>:	lea    -0x42cd(%ebx),%edx ; "delabere"
   0x00001465 <+405>:	call   0x1040 <strcmp@plt>
   0x0000146a <+410>:	cmp    $0x0,%eax
   0x0000146d <+413>:	jne    0x1480 <main+432>
   0x00001473 <+419>:	call   0x12a0 <ok> 
   0x00001480 <+432>:	call   0x1220 <no> 
   0x00001488 <+440>:	xor    %eax,%eax
   0x0000148d <+445>:	pop    %ebx
   0x0000148f <+447>:	ret
```
## step by step explain

- Verifies exactly 1 item was scanned (ret == 1) at scanf call 
- Checks first two characters are '0' (input[0] == '0' && input[1] == '0')
- Initializes a target buffer[0] with 'd'
- then set the index to 2 and starting a loop 
- Processes input in 3-character chunks
- Converts each chunk to an integer using atoi()
- Stores the result in the target buffer which must be an 8 caracter length
- Compares processed target buffer with "delabere"
- Calls ok() if match, no() otherwise

##### Key Generation Logic
The input string must:

- Start with "00"
Breaking down "delabere":

d = 100 will be ignored sens it is allready sat
e = 101
l = 108
a = 97 => 97+/- to match 3 caracters atoi skip the +/- caracters
b = 98 => 98+/-  
e = 101
r = 114
e = 101
##### Solution Construction
The valid key combines:

Prefix "00"

ASCII codes for "delabere" in 3-digit format:
```bash
101 (e)

108 (l)

97+/- (a)

98+/- (b)

101 (e)

114 (r)

101 (e)
```
Final key: 0010110897+98+101114101
or 0010110897-98-101114101

Verification with GDB
Set breakpoint at strcmp:

```bash
(gdb) b strcmp
(gdb) run
Please enter key: 0010110897+98+101114101
```
Examine arguments:


```bash
(gdb) x/s $ecx
0xffffd1a0:	"delabere"  # Processed target buffer

(gdb) x/s $edx
0x5655900b:	"delabere"  # Hardcoded comparison string
(gdb) c                 # continue program run
Continuing.
Good job.
```