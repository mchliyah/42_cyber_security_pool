# level3

in this level i will just put the gdb with comment i try to explain every step :) the same as the other levels


```bash
0x0000555555555320 <+0>:	push   %rbp                        # Save base pointer
0x0000555555555321 <+1>:	mov    %rsp,%rbp                   # Set up new base pointer
0x0000555555555324 <+4>:	sub    $0x60,%rsp                  # Allocate 96 bytes on stack
0x0000555555555328 <+8>:	movl   $0x0,-0x4(%rbp)             # int i = 0;

0x000055555555532f <+15>:	lea    0xd0d(%rip),%rdi            # Load address of "input: " format string
0x0000555555555336 <+22>:	mov    $0x0,%al                    # Clear AL before variadic call
0x0000555555555338 <+24>:	call   0x555555555050 <printf@plt> # Call printf("input: ");

0x000055555555533d <+29>:	lea    -0x40(%rbp),%rsi            # Load address of input buffer
0x0000555555555341 <+33>:	lea    0xd0e(%rip),%rdi            # Load address of "%s" format
0x0000555555555348 <+40>:	mov    $0x0,%al                    # Clear AL before scanf
0x000055555555534a <+42>:	call   0x5555555550a0 <__isoc99_scanf@plt> # Call scanf("%s", input);

0x000055555555534f <+47>:	mov    %eax,-0x8(%rbp)             # Save scanf return value

0x0000555555555352 <+50>:	mov    $0x1,%eax                   # Set eax = 1
0x0000555555555357 <+55>:	cmp    -0x8(%rbp),%eax             # if (scanf_ret != 1)
0x000055555555535a <+58>:	je     0x555555555365 <main+69>    # continue if equal

0x0000555555555360 <+64>:	call   0x5555555552e0 <___syscall_malloc> # exit() if scanf failed

0x0000555555555365 <+69>:	movsbl -0x3f(%rbp),%ecx            # char c = input[1];
0x0000555555555369 <+73>:	mov    $0x32,%eax                  # ASCII '2'
0x000055555555536e <+78>:	cmp    %ecx,%eax                   # if (c != '2')
0x0000555555555370 <+80>:	je     0x55555555537b <main+91>    # continue if c == '2'

0x0000555555555376 <+86>:	call   0x5555555552e0 <___syscall_malloc> # exit if not '2'

0x000055555555537b <+91>:	movsbl -0x40(%rbp),%ecx            # char c = input[0];
0x000055555555537f <+95>:	mov    $0x34,%eax                  # ASCII '4'
0x0000555555555384 <+100>:	cmp    %ecx,%eax                   # if (c != '4')
0x0000555555555386 <+102>:	je     0x555555555391 <main+113>   # continue if c == '4'

0x000055555555538c <+108>:	call   0x5555555552e0 <___syscall_malloc> # exit if not '4'

0x0000555555555391 <+113>:	mov    0x2c48(%rip),%rax           # Get address of stdout
0x0000555555555398 <+120>:	mov    (%rax),%rdi                 # Load stdout into rdi
0x000055555555539b <+123>:	call   0x555555555080 <fflush@plt> # Call fflush(stdout)

0x00005555555553a0 <+128>:	lea    -0x21(%rbp),%rdi            # Destination buffer
0x00005555555553a4 <+132>:	xor    %esi,%esi                   # Fill with 0
0x00005555555553a6 <+134>:	mov    $0x9,%edx                   # Length = 9
0x00005555555553ab <+139>:	call   0x555555555060 <memset@plt> # memset(buf, 0, 9)

0x00005555555553b0 <+144>:	movb   $0x2a,-0x21(%rbp)           # buf[0] = '*'
0x00005555555553b4 <+148>:	movb   $0x0,-0x41(%rbp)            # Clear a byte
0x00005555555553b8 <+152>:	movq   $0x2,-0x18(%rbp)            # i = 2
0x00005555555553c0 <+160>:	movl   $0x1,-0xc(%rbp)             # j = 1

# --- loop start
0x00005555555553c7 <+167>:	lea    -0x21(%rbp),%rdi            # strlen(buf)
0x00005555555553cb <+171>:	call   0x555555555040 <strlen@plt>
0x00005555555553d0 <+176>:	mov    %rax,%rcx                   # rcx = strlen(buf)
0x00005555555553d3 <+179>:	xor    %eax,%eax                   # Clear eax
0x00005555555553d5 <+181>:	cmp    $0x8,%rcx                   # if (strlen >= 8)
0x00005555555553d9 <+185>:	mov    %al,-0x45(%rbp)             # Set loop flag = 0
0x00005555555553dc <+188>:	jae    0x555555555403 <main+227>   # Jump if >= 8

0x00005555555553e2 <+194>:	mov    -0x18(%rbp),%rax            # i
0x00005555555553e6 <+198>:	mov    %rax,-0x50(%rbp)            # Save i
0x00005555555553ea <+202>:	lea    -0x40(%rbp),%rdi            # input
0x00005555555553ee <+206>:	call   0x555555555040 <strlen@plt> # strlen(input)
0x00005555555553f3 <+211>:	mov    %rax,%rcx
0x00005555555553f6 <+214>:	mov    -0x50(%rbp),%rax            # i
0x00005555555553fa <+218>:	cmp    %rcx,%rax                   # if i < strlen
0x00005555555553fd <+221>:	setb   %al                         # AL = (i < strlen) ? 1 : 0
0x0000555555555400 <+224>:	mov    %al,-0x45(%rbp)             # loop flag

0x0000555555555403 <+227>:	mov    -0x45(%rbp),%al             # test loop flag
0x0000555555555406 <+230>:	test   $0x1,%al
0x0000555555555408 <+232>:	jne    0x555555555413 <main+243>   # If true, continue loop
0x000055555555540e <+238>:	jmp    0x555555555461 <main+321>   # Else, break

# --- inside loop
0x0000555555555413 <+243>:	mov    -0x18(%rbp),%rax
0x0000555555555417 <+247>:	mov    -0x40(%rbp,%rax,1),%al      # input[i]
0x000055555555541b <+251>:	mov    %al,-0x44(%rbp)             # Save char1

0x000055555555541e <+254>:	mov    -0x18(%rbp),%rax
0x0000555555555422 <+258>:	mov    -0x3f(%rbp,%rax,1),%al      # input[i+1]
0x0000555555555426 <+262>:	mov    %al,-0x43(%rbp)             # Save char2

0x0000555555555429 <+265>:	mov    -0x18(%rbp),%rax
0x000055555555542d <+269>:	mov    -0x3e(%rbp,%rax,1),%al      # input[i+2]
0x0000555555555431 <+273>:	mov    %al,-0x42(%rbp)             # Save char3

0x0000555555555434 <+276>:	lea    -0x44(%rbp),%rdi            # addr of 3-byte string
0x0000555555555438 <+280>:	call   0x555555555090 <atoi@plt>   # convert to int
0x000055555555543d <+285>:	mov    %al,%cl                     # get result in cl

0x000055555555543f <+287>:	movslq -0xc(%rbp),%rax             # j
0x0000555555555443 <+291>:	mov    %cl,-0x21(%rbp,%rax,1)      # buf[j] = atoi(input[i:i+3])

0x0000555555555447 <+295>:	mov    -0x18(%rbp),%rax
0x000055555555544b <+299>:	add    $0x3,%rax                   # i += 3
0x000055555555544f <+303>:	mov    %rax,-0x18(%rbp)

0x0000555555555453 <+307>:	mov    -0xc(%rbp),%eax
0x0000555555555456 <+310>:	add    $0x1,%eax                   # j++
0x0000555555555459 <+313>:	mov    %eax,-0xc(%rbp)

0x000055555555545c <+316>:	jmp    0x5555555553c7 <main+167>   # Loop back

# --- after loop
0x0000555555555461 <+321>:	lea    -0x21(%rbp),%rdi
0x0000555555555465 <+325>:	call   0x555555555030 <puts@plt>   # puts(buf)

0x000055555555546a <+330>:	mov    $0x0,%eax                   # return 0
0x000055555555546f <+335>:	leave                              
0x0000555555555470 <+336>:	ret

```

### importent steps to focus on

this program contain 3 mportent steps 

##### 1 

the firs two caracter input are "42"
```bash
0x0000555555555369: cmp $0x32,%ecx  # Verify 2nd char is '2' (input[1] == '2')
0x000055555555537f: cmp $0x34,%ecx  # Verify 1st char is '4' (input[0] == '4')
```

##### 2

Buffer Initialization:

```bash
0x00005555555553a0: lea -0x21(%rbp),%rdi  # 9-byte target buffer
0x00005555555553ab: call memset@plt       # Zero-initialize buffer
0x00005555555553b0: movb $0x2a,-0x21(%rbp) # Set first byte to '*' (0x2a)
```

##### 3

Loop and final cmp:


```bash
0x0000555555555417: mov -0x40(%rbp,%rax,1),%al  # Load input[i]
0x0000555555555438: call atoi@plt               # Convert 3-char chunk to integer
0x000055555555543f: mov %cl,-0x21(%rbp,%rax,1)  # Store as byte in buffer
```
Processes input in 3-character chunks starting at index 2
Stores result in buffer[j] where j increments by 1 each iteration

Loop Control:

```bash
0x00005555555553d5: cmp $0x8,%rcx  # Continue until buffer has 8 bytes
0x000055555555544b: add $0x3,%rax   # i += 3 (input index)
0x0000555555555459: add $0x1,%eax   # j += 1 (buffer index)
```
final cmp:
a break after loop 
```bash
b *0x0000555555555461  # After loop
x/s $rbp-0x21      # Should show "********"